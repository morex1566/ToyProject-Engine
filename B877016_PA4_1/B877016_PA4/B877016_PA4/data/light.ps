////////////////////////////////////////////////////////////////////////////////
// Filename: light.ps
////////////////////////////////////////////////////////////////////////////////

#define NUM_LIGHTS 10

/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
Texture2D fireTexture;
Texture2D noiseTexture;
Texture2D alphaTexture;

SamplerState SampleType2; // for clamp
SamplerState SampleType;  // for wrap

cbuffer LightBuffer
{
	float4 ambientColor;
	float4 diffuseColor;
    float3 lightDirection;
    float specularPower;
    float4 specularColor;
	float ambientOnOff;
	float diffuseOnOff;
	float specularOnOff;
	float padding;
};

cbuffer LightColorBuffer
{
    float4 pointDiffuseColor[NUM_LIGHTS];
};

cbuffer DistortionBuffer
{
    float2 distortion1;
    float2 distortion2;
    float2 distortion3;
    float distortionScale;
    float distortionBias;
};

cbuffer ToggleBuffer
{
    int fireOn;
    float3 togglePadding;
};

cbuffer NoiseBuffer
{
    float frameTime;
    float3 scrollSpeeds;
    float3 scales;
    float padding1;
};

//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
	float3 viewDirection : TEXCOORD1;
	float3 pointLightPos1 : TEXCOORD2;
	float3 pointLightPos2 : TEXCOORD3;
	float3 pointLightPos3 : TEXCOORD4;
	float3 pointLightPos4 : TEXCOORD5;
	float3 pointLightPos5 : TEXCOORD6;
	float3 pointLightPos6 : TEXCOORD7;
	float3 pointLightPos7 : TEXCOORD8;
	float3 pointLightPos8 : TEXCOORD9;
	float3 pointLightPos9 : TEXCOORD10;
	float3 pointLightPos10 : TEXCOORD11;
	float3 pointIntensity1 : TEXCOORD12;
    float3 pointIntensity2 : TEXCOORD13;
    float3 pointIntensity3 : TEXCOORD14;
    float3 pointIntensity4 : TEXCOORD15;
    float3 pointIntensity5 : TEXCOORD16;
	float3 pointIntensity6 : TEXCOORD17;
    float3 pointIntensity7 : TEXCOORD18;
    float3 pointIntensity8 : TEXCOORD19;
    float3 pointIntensity9 : TEXCOORD20;
    float3 pointIntensity10 : TEXCOORD21;
    float2 texCoords1 : TEXCOORD22;
    float2 texCoords2 : TEXCOORD23;
    float2 texCoords3 : TEXCOORD24;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	float4 textureColor;
	float3 lightDir;
	float lightIntensity;
	float4 color; 
	float3 reflection;
    float4 specular;
	float lightIntensity1, lightIntensity2, lightIntensity3, lightIntensity4, lightIntensity5; // point light intensity
	float lightIntensity6, lightIntensity7, lightIntensity8, lightIntensity9, lightIntensity10; // point light intensity
	float4 color1, color2, color3, color4, color5; // point light color
	float4 color6, color7, color8, color9, color10; // point light color


    float4 noise1, noise2, noise3, retNoise;
    float perturb;
    float2 noiseCoords;
    float4 fireColor;
    float4 alphaColor;

    float4 retColor;

    // direction light
	textureColor = shaderTexture.Sample(SampleType, input.tex);
    color = ambientColor * ambientOnOff;
	specular = float4(0.0f, 0.0f, 0.0f, 0.0f);

	// Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Calculate the amount of light on this pixel.
    lightIntensity = saturate(dot(input.normal, lightDir));

	if(lightIntensity > 0.0f)
    {
        // Determine the final diffuse color based on the diffuse color and the amount of light intensity.
        color += (diffuseColor * lightIntensity * diffuseOnOff);

	    // Saturate the ambient and diffuse color.
		color = saturate(color);

		// Calculate the reflection vector based on the light intensity, normal vector, and light direction.
        reflection = normalize(2 * lightIntensity * input.normal - lightDir); 

		// Determine the amount of specular light based on the reflection vector, viewing direction, and specular power.
        specular = pow(saturate(dot(reflection, input.viewDirection)), specularPower) * specularOnOff;
    }

    // Multiply the texture pixel and the input color to get the textured result.
    color = color * textureColor;

	// Add the specular component last to the output color.
    color = saturate(color + specular);


	/* point light implement */
	lightIntensity1 = saturate(dot(input.normal, input.pointLightPos1));
    lightIntensity2 = saturate(dot(input.normal, input.pointLightPos2));
    lightIntensity3 = saturate(dot(input.normal, input.pointLightPos3));
    lightIntensity4 = saturate(dot(input.normal, input.pointLightPos4));
    lightIntensity5 = saturate(dot(input.normal, input.pointLightPos5));
	lightIntensity6 = saturate(dot(input.normal, input.pointLightPos6));
    lightIntensity7 = saturate(dot(input.normal, input.pointLightPos7));
    lightIntensity8 = saturate(dot(input.normal, input.pointLightPos8));
    lightIntensity9 = saturate(dot(input.normal, input.pointLightPos9));
    lightIntensity10 = saturate(dot(input.normal, input.pointLightPos10));

	color1 = pointDiffuseColor[0] * lightIntensity1 * 1.0f * input.pointIntensity1.x;
    color2 = pointDiffuseColor[1] * lightIntensity2 * 1.0f * input.pointIntensity2.x;
    color3 = pointDiffuseColor[2] * lightIntensity3 * 0.75f * input.pointIntensity3.x;
    color4 = pointDiffuseColor[3] * lightIntensity4 * 0.8f * input.pointIntensity4.x;
    color5 = pointDiffuseColor[4] * lightIntensity5 * 0.8f * input.pointIntensity5.x;
	color6 = pointDiffuseColor[5] * lightIntensity6 * 0.8f * input.pointIntensity6.x;
    color7 = pointDiffuseColor[6] * lightIntensity7 * 0.8f * input.pointIntensity7.x;
    color8 = pointDiffuseColor[7] * lightIntensity8 * 1.0f * input.pointIntensity8.x;
    color9 = pointDiffuseColor[8] * lightIntensity9 * 0.75f * input.pointIntensity9.x;
    color10 = pointDiffuseColor[9] * lightIntensity10 * 0.75f * input.pointIntensity10.x;

	color = color + (saturate(color1 + color2 + color3 + color4 + color5 + 
							  color6 + color7 + color8 + color9 + color10 ) * textureColor);


    /* fire implement */
    if(fireOn)
    {
    // sample texture.



    //(frameTime * scrollSpeeds.x);
    noise1 = noiseTexture.Sample(SampleType, input.texCoords1);
    noise2 = noiseTexture.Sample(SampleType, input.texCoords2);
    noise3 = noiseTexture.Sample(SampleType, input.texCoords3);


    // clamp texture to (-1, 1)
    noise1 = (noise1 - 0.5f) * 2.0f;
    noise2 = (noise2 - 0.5f) * 2.0f;
    noise3 = (noise3 - 0.5f) * 2.0f;

    // distort texture.
    noise1.xy = noise1.xy * distortion1.xy;
    noise2.xy = noise2.xy * distortion2.xy;
    noise3.xy = noise3.xy * distortion3.xy;


    // synthesis noise texture.
    retNoise = noise1 + noise2 + noise3;

    // make noised coord.
    perturb = ((1.0f - input.tex.y) * distortionScale) + distortionBias + distortionBias;
    noiseCoords.xy = (retNoise.xy * perturb) + input.tex.xy;


    // get texture coord from noised coord.
    fireColor = fireTexture.Sample(SampleType2, noiseCoords.xy);
    alphaColor = alphaTexture.Sample(SampleType2, noiseCoords.xy);

    // combine alpha-value.

        fireColor.a = alphaColor;
        retColor = fireColor;
    }
    else
    {
        retColor = color;
    }

    return retColor;
}